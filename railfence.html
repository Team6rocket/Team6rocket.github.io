<html><link type="text/css" rel="stylesheet" id="dark-mode-custom-link"><link type="text/css" rel="stylesheet" id="dark-mode-general-link"><style type="text/css" id="dark-mode-custom-style" lang="en"></style><style type="text/css" id="dark-mode-native-style" lang="en"></style><head><script>(function(){function hookGeo() {
  
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); 
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); 
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { 
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); 
    }

    
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; 
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  window.addEventListener('message', function (event) {
    if (event.source !== window) {
      return;
    }
    const message = event.data;
    switch (message.method) {
      case 'updateLocation':
        if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
          hookedObj.genLat = message.info.coords.lat;
          hookedObj.genLon = message.info.coords.lon;
          hookedObj.fakeGeo = message.info.fakeIt;
        }
        break;
      default:
        break;
    }
  }, false);
  //]]>
}hookGeo();})()</script><title>Railfence</title>
<link rel="SHORTCUT ICON" href="/favicon.ico">

<script language="JavaScript" src="railfence.js"></script>
<script language="JavaScript" src="util.js"></script>
<script language="JavaScript"><!--

function start_update()
{
   if (! document.getElementById)
   {
      alert('Sorry, you need a newer browser.');
      return;
   }

   if ((! document.Railfence_Loaded) || (! document.Util_Loaded) ||
       (! document.getElementById('output')))
   {
      window.setTimeout('start_update()', 100);
      return;
   }
   upd();
}


function upd()
{
   var e, r;

   if (IsUnchanged(document.encoder.text) *
       IsUnchanged(document.encoder.encdec) *
       IsUnchanged(document.encoder.rails) *
       IsUnchanged(document.encoder.offset))
   {
      window.setTimeout('upd()', 100);
      return;
   }

   ResizeTextArea(document.encoder.text);

   if (document.encoder.text.value== '')
   {
      e = document.getElementById('output');
      e.innerHTML = 'Enter a message and see the results here!';
      e = document.getElementById('rails_disp');
      e.innerHTML = 'There is no message to show.';
      setTimeout('upd()', 100);
      return;
   }

   r = Railfence(document.encoder.encdec.value * 1, 
      document.encoder.text.value, document.encoder.rails.value * 1, 
      document.encoder.offset.value * 1);
   
   e = document.getElementById('output');
   e.innerHTML = SwapSpaces(HTMLEscape(r));
   
   e = document.getElementById('rails_disp');
   if (document.encoder.encdec.value * 1 > 0)
   {
      e.innerHTML = FormatRails(document.encoder.text.value, 
         document.encoder.rails.value * 1, document.encoder.offset.value * 1);
   }
   else
   {
      e.innerHTML = FormatRails(r, document.encoder.rails.value * 1, 
         document.encoder.offset.value * 1);
   }
   
   window.setTimeout('upd()', 100);
}


function FormatRails(text, rails, offset)
{
   var o = new Array(rails), off = new Array(2 * (rails - 1));
   var i, j, off, pos;
   
   for (i = 0; i < rails; i ++)
   {
      o[i] = "";
      off[i] = i;
   }
   
   for (i = rails; i < 2 * (rails - 1); i ++)
   {
      off[i] = (2 * (rails - 1)) - i;
   }
   
   pos = offset % (2 * (rails - 1));
   
   for (i = 0; i < text.length; i ++)
   {
      for (j = 0; j < rails; j ++)
      {
         if (off[pos] == j)
	 {
	    o[j] += text.charAt(i);
	 }
	 else
	 {
	    o[j] += '&nbsp;';
	 }
      }
      pos = (pos + 1) % (2 * (rails - 1));
   }
   
   
   j = "";
   for (i = 0; i < rails; i ++)
   {
      if (i)
      {
         j += "<br>\n";
      }
      j += o[i];
   }
   
   return '<tt><b>' + j + '</b></tt>';
}

toggle = 0;
function ToggleRails()
{
   var Link, Vis;
   
   if (toggle == 0)
   {
      toggle = 1;
      Link = "Hide the rails";
      Vis = "block";
   }
   else
   {
      toggle = 0;
      Link = "Show the rails";
      Vis = "none";
   }
   
   e = document.getElementById('rails_link');
   e.innerHTML = Link;
   
   e = document.getElementById('rails_disp');
   e.style.display = Vis;
}

window.setTimeout('start_update()', 100);
      
// --></script>
<link rel="stylesheet" type="text/css" href="base.css">
<link rel="stylesheet" type="text/css" media="screen,projection" href="normal.css">
<link rel="stylesheet" type="text/css" media="print" href="print.css">
<script src="/inc/js/site.js?1" type="text/javascript"></script>
<style type="text/css">
  #content img {
    position: absolute;
    top: 0px;
    left: 0px;
}
</style>
</head>
<body>
   <div id="content">
    <img src="logo.jpg" width="400px" height="100px">
</div>
<br>
<br>
<br>
<br>
<br>
<br>
<table width="100%" height="100%" cellspacing="0" cellpadding="0" border="0">
<tbody><tr><td valign="top">


<table width="100%" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td width="99%" valign="top"><div class="r_main">

<p>When you rearrange your text in a "wave" sort of pattern (down, down, up,
up, down, down, etc.), it is called a railfence.  Take the text "WAFFLES FOR
BREAKFAST" and arrange them in waves like the diagram below.  I substituted
* for spaces just to illustrate that the spaces are not removed.</p>

<p><tt>W&nbsp;&nbsp;&nbsp;L&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;K&nbsp;&nbsp;&nbsp;T<br>
&nbsp;A&nbsp;F&nbsp;E&nbsp;*&nbsp;O&nbsp;*&nbsp;R&nbsp;A&nbsp;F&nbsp;S<br>
&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;A</tt></p>

<p>You leave the spaces in.  Next, you squish together the lines,
remembering to keep the spaces in.  I did not replace spaces with stars
since the spaces are clearly shown in the middle line.</p>

<p><tt>WLFBKT<br>AFE O RAFS<br>FSREA</tt></p>

<p>Then you just combine the lines and get <tt>WLFBKTAFE O RAFSFSREA</tt>.
Or you can use this JavaScript-based tool and speed things up quite a bit.
There is <a href="http://www.woodmann.com/fravia/railfe.htm">another site</a> with more
of a description and another encoder.</p>

<form name="encoder" method="post" action="#" onsubmit="return false;">
<p><select name="encdec" _oldvalue="1">
   <option value="1">Encrypt
   </option><option value="-1">Decrypt
</option></select>
</p><p>Rails:  <input type="text" name="rails" value="3" _oldvalue="3"> – The number of rows,
which determines the height of the waves.</p>
<p>Offset:  <input type="text" name="offset" value="0" _oldvalue="0"> – Instead of
starting on the top rail and working down, you can start on any rail and
move up or down depending on where you place the offset.  Should be less
than (rail * 2 - 1).</p>
<p>Your message:<br><textarea name="text" rows="2" cols="40" _oldvalue=""></textarea></p>
</form>
<p><a id="rails_link" href="#" onclick="ToggleRails(); return false">Show the
rails</a></p>
<div style="display: none" id="rails_disp">There is no message to show.</div>
<p>This is your encoded or decoded text.  It may be hard to see spaces
at the beginning, end, or two in a row.
Be careful when copying encrypted text and make sure that it will
decrypt to the message properly.</p>
<table class="r_box" style="margin-top: 8px; margin-bottom: 8px;font-family: monospace" cellspacing="0" cellpadding="0" border="0" align="center"><tbody><tr><td class="r_box"><span id="output">Enter a message and see the results here!</span>
</td></tr></tbody></table><div style="clear: both"></div>
</div>

<img src="logo.jpg" style="float: right; margin-left: 2px; margin-bottom: 2px; height:100px">
</td></tr></tbody></table>
</td></tr>
</tbody></table>


</body></html>
