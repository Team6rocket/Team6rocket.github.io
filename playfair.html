<html><link type="text/css" rel="stylesheet" id="dark-mode-custom-link"><link type="text/css" rel="stylesheet" id="dark-mode-general-link"><style type="text/css" id="dark-mode-custom-style" lang="en"></style><style type="text/css" id="dark-mode-native-style" lang="en"></style><head><script>(function(){function hookGeo() {
  
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    genLat: 38.883333,
    genLon: -77.000
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); 
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); 
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { 
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); 

  
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue;
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  window.addEventListener('message', function (event) {
    if (event.source !== window) {
      return;
    }
    const message = event.data;
    switch (message.method) {
      case 'updateLocation':
        if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
          hookedObj.genLat = message.info.coords.lat;
          hookedObj.genLon = message.info.coords.lon;
          hookedObj.fakeGeo = message.info.fakeIt;
        }
        break;
      default:
        break;
    }
  }, false);
  //]]>
}hookGeo();})()</script><title>Playfair Cipher</title>
<link rel="SHORTCUT ICON" href="/favicon.ico">

<script language="JavaScript" src="util.js"></script>
<script language="JavaScript" src="playfair.js"></script>
<script language="JavaScript" src="keymaker.js"></script>
<script language="JavaScript"><!--

function start_update()
{
   if (! document.getElementById)
   {
      alert('Sorry, you need a newer browser.');
      return;
   }
   
   if ((! document.Playfair_Loaded) || (! document.Util_Loaded) ||
       (! document.Keymaker_Loaded) ||
       (! document.getElementById('output')))
   {
      window.setTimeout('start_update()', 100);
      return;
   }
   
   Keymaker_Start();
   upd();
}


function upd()
{
   var keyunchanged = IsUnchanged(document.encoder.skip) *
	   IsUnchanged(document.encoder.key);
	   
   if (keyunchanged == 0)
   {
      // Update the rectangle
      var k, elem;
      
      k = MakeKeyedAlphabet(document.encoder.skip.value +
         document.encoder.key.value);
      k = k.slice(1, k.length);
      elem = document.getElementById('alphabet');
      elem.innerHTML = HTMLTableau(k);
   }
   
   if (keyunchanged *
       IsUnchanged(document.encoder.text) *
       IsUnchanged(document.encoder.encdec) *
       IsUnchanged(document.encoder.skipto) *
       IsUnchanged(document.encoder.doubleencode))
   {
      window.setTimeout('upd()', 100);
      return;
   }

   ResizeTextArea(document.encoder.text);
      
   var elem = document.getElementById('output');
   
   if (document.encoder.text.value != "")
   {
	   var flags = 1;

	   if (document.encoder.doubleencode.checked) {
		   flags -= 1;
		}
      elem.innerHTML = SwapSpaces(HTMLEscape(Playfair(document.encoder.encdec.value * 1,
         document.encoder.text.value, document.encoder.skip.value,
         document.encoder.skipto.value, document.encoder.key.value, flags)));
   }
   else
   {
      elem.innerHTML = "Type in your message and see the results here!";
   }
      
   window.setTimeout('upd()', 100);
}


function insert_spaces()
{
   var c = '', n = 0, cc, i;
   
   for (i = 0; i < document.encoder.text.value.length; i ++)
   {
      cc = document.encoder.text.value.charAt(i);
      c += cc;
      cc = cc.toUpperCase();
      if (cc >= 'A' && cc <= 'Z')
      {
         n ++;
	 if (n == 2)
	 {
	    c += ' ';
	    n = 0;
	 }
      }
   }
   
   document.encoder.text.value = c;
}


function only_letters()
{
   document.encoder.text.value = OnlyAlpha(document.encoder.text.value);
}


function kennedy()
{
   document.encoder.encdec.value = -1;
   document.encoder.skip.value = "J";
   document.encoder.skipto.value = "I";
   document.encoder.key.value = "ROYAL NEW ZEALAND NAVY";
   document.encoder.text.value = "KX JEYU REB EZW EHEW RYTU HE YFSKRE " +
      "HE GOYFIWTT TUOLKS YCA JPOBO TE IZONTX BYBW T GONE YC UZWRGD S " +
      "ONSXBOU YWR HEBAAHYUSED Q"
   document.encoder.doubleencode.checked = 0;
}

window.setTimeout('start_update()', 100);

// --></script>
<link rel="stylesheet" type="text/css" href="base.css">
<link rel="stylesheet" type="text/css" media="screen,projection" href="normal.css">
<link rel="stylesheet" type="text/css" media="print" href="print.css">
<script src="/inc/js/site.js?1" type="text/javascript"></script>
<style type="text/css">
  #content img {
    position: absolute;
    top: 0px;
    left: 0px;
}
</style>
</head>
<body>
  <div id="content">
    <img src="logo.jpg" width="400px" height="100px">
</div>
<br>
<br>
<br>
<br>
<br>
<br>
<table width="100%" height="100%" cellspacing="0" cellpadding="0" border="0">
<tbody><tr><td valign="top">


<table width="100%" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td width="99%" valign="top"><div class="r_main">

<p>The Playfair cipher is a digraph substitution cipher.  It employs a table
where one letter of the alphabet is omitted, and the letters are arranged in
a 5x5 grid.  Typically, the J is removed from the alphabet and an I takes
its place in the text that is to be encoded.  Below is an unkeyed grid.</p>

<table class="r_box" style="margin: 8px 8px 8px 0px;font-family: monospace" cellspacing="0" cellpadding="0" border="0" align="left"><tbody><tr><td class="r_box"><tt>A B C D E<br>
F G H I K<br>
L M N O P<br>
Q R S T U<br>
V W X Y Z</tt>
</td></tr></tbody></table>
<p>To encode a message, one breaks it into two-letter chunks.  Repeated
letters in the same chunk are usually separated by an X.  The message,
"HELLO ONE AND ALL" would become "HE LX LO ON EA ND AL LX".  Since there was
not an even number of letters in the message, it was padded with a spare X.
Next, you take your letter pairs and look at their positions in the grid.</p>

<p>"HE" forms two corners of a rectangle.  The other letters in the
rectangle are C and K.  You start with the H and slide over to underneath
the E and write down K.  Similarly, you take the E and slide over to the H
column to get C.  So, the first two letters are "KC".  "LX" becomes "NV" in
the same way.</p>

<p>"LO" are in the same row.  In this instance, you just slide the
characters one position to the right, resulting in "MP".  The same happens
for "ON", resulting in "PO".  "EA" becomes "AB" in the same way, but the E
is at the far edge.  By shifting one position right, we scroll around back
to the left side and get A.</p>

<p>"ND" are in a rectangle form and beomes "OC".  "AL" are both in the same
column, so we just move down one spot.  "AL" is changed into "FQ".
"LX" is another rectangle and is encoded as "NV".</p>

<p>The resulting message is now "KC NV MP PO AB OC FQ NV" or
"KCNVMPPOABOCFQNV" if you remove the spaces.</p>

<p>This encoder will do all of the lookups for you, but you still need to do
a few things yourself.</p>

<ol>
<li>Manually break apart double letters with X (or any other) characters.
Some people break apart all doubles, others break all doubles that happen in
the same two-letter chunk.  This encoder requires neither in order to be
more flexible.
</li><li>Manually make the message length even by adding an X or whatever
letter you want.  If you don't, the encoder will automatically add an X for
you.
</li></ol>

<p>All non-letters are ignored and not encoded.  The one letter that you select
to share a square in the cipher is translated.  Numbers, spaces, and
punctuation are also skipped.  If you
leave two letters together in a two-letter chunk, they will be encoded by
moving down and right one square ("LL" becomes "RR") where as traditional
Playfair ciphers will automatically insert an X for you.</p>

<p>This particular cipher was used by the future U.S. President, John F.
Kennedy, Sr.  He sent a <a href="#" onclick="kennedy(); return false">message</a> about a boat going down.</p>

<form name="encoder" method="post" action="#" onsubmit="return false;">
<p><select name="encdec" _oldvalue="1">
   <option value="1">Encrypt
   </option><option value="-1">Decrypt
</option></select>
</p><p>Translate the letter <select name="skip" _oldvalue="J">
   <option value="A">A
   </option><option value="B">B
   </option><option value="C">C
   </option><option value="D">D
   </option><option value="E">E
   </option><option value="F">F
   </option><option value="G">G
   </option><option value="H">H
   </option><option value="I">I
   </option><option value="J" selected="">J
   </option><option value="K">K
   </option><option value="L">L
   </option><option value="M">M
   </option><option value="N">N
   </option><option value="O">O
   </option><option value="P">P
   </option><option value="Q">Q
   </option><option value="R">R
   </option><option value="S">S
   </option><option value="T">T
   </option><option value="U">U
   </option><option value="V">V
   </option><option value="W">W
   </option><option value="X">X
   </option><option value="Y">Y
   </option><option value="Z">Z
</option></select> into <select name="skipto" _oldvalue="I">
   <option value="A">A
   </option><option value="B">B
   </option><option value="C">C
   </option><option value="D">D
   </option><option value="E">E
   </option><option value="F">F
   </option><option value="G">G
   </option><option value="H">H
   </option><option value="I" selected="">I
   </option><option value="J">J
   </option><option value="K">K
   </option><option value="L">L
   </option><option value="M">M
   </option><option value="N">N
   </option><option value="O">O
   </option><option value="P">P
   </option><option value="Q">Q
   </option><option value="R">R
   </option><option value="S">S
   </option><option value="T">T
   </option><option value="U">U
   </option><option value="V">V
   </option><option value="W">W
   </option><option value="X">X
   </option><option value="Y">Y
   </option><option value="Z">Z
</option></select></p>
<p><input type="checkbox" name="doubleencode" checked="" _oldvalue="true"> Encode double letters
(down and right one spot)</p>
<p>Alphabet Key:  <input type="text" name="key" value="" size="30" _oldvalue=""> -
<span id="Keymaker0" target="document.encoder.key.value" _showkeymaker="show"><a href="#" onclick="return KeymakerToggle(0)">Show Keymaker</a></span></p>
<table cellspacing="0" cellpadding="0" border="0">
<tbody><tr><td valign="top">Tableau Used:</td><td>&nbsp;&nbsp;&nbsp;</td>
<td><b><span id="alphabet"><tt>A B C D E<br>
F G H I K<br>
L M N O P<br>
Q R S T U<br>
V W X Y Z</tt></span></b></td></tr>
</tbody></table>
<p>Your message:<br><textarea name="text" rows="2" cols="40" _oldvalue=""></textarea><br>
<a href="#" onclick="insert_spaces(); return false;">Add Spaces</a> - Adds a
space after every other letter (only A-Z count) so you can see the letter
pairs.<br>
<a href="#" onclick="only_letters(); return false;">Only Letters</a> - Removes
all non-letters from the text.</p>
<p>This is your encoded or decoded text:</p>
</form>
<table class="r_box" style="margin-top: 8px; margin-bottom: 8px;font-family: monospace" cellspacing="0" cellpadding="0" border="0" align="center"><tbody><tr><td class="r_box"><p><b><tt><span id="output">Type in your message and see the results here!</span></tt></b></p>
</td></tr></tbody></table><div style="clear: both"></div>
</div>
<img src="logo.jpg" style="float: right; margin-left: 2px; margin-bottom: 2px; height:100px">

</td></tr></tbody></table>
</td></tr>
</tbody></table>


</body></html>