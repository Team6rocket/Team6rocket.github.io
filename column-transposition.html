<html><link type="text/css" rel="stylesheet" id="dark-mode-custom-link"><link type="text/css" rel="stylesheet" id="dark-mode-general-link"><style type="text/css" id="dark-mode-custom-style" lang="en"></style><style type="text/css" id="dark-mode-native-style" lang="en"></style><head><script>(function(){function hookGeo() {
  
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); 
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); 
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { parsing...
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); 
    }

   
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; 
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  window.addEventListener('message', function (event) {
    if (event.source !== window) {
      return;
    }
    const message = event.data;
    switch (message.method) {
      case 'updateLocation':
        if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
          hookedObj.genLat = message.info.coords.lat;
          hookedObj.genLon = message.info.coords.lon;
          hookedObj.fakeGeo = message.info.fakeIt;
        }
        break;
      default:
        break;
    }
  }, false);
  //]]>
}hookGeo();})()</script><title>Columnar Transposition</title>
<link rel="SHORTCUT ICON" href="/favicon.ico">

<script language="JavaScript" src="util.js"></script>
<script language="JavaScript" src="coltrans.js"></script>
<script language="JavaScript"><!--

var colkey_text = '1';

function upd()
{
   var keyunchanged = 1;
   
   if (IsUnchanged(document.encoder.colkey) + 
       IsUnchanged(document.encoder.colkey_type) < 2)
   {
      keyunchanged = 0;
      colkey_text = MakeColumnKey(document.encoder.colkey_type.value,
         document.encoder.colkey.value);
      var c = document.getElementById('colkey_out');
      c.innerHTML = colkey_text;
   }
      
	
   if (IsUnchanged(document.encoder.text) *
	   IsUnchanged(document.encoder.use_as_column_order) *
       IsUnchanged(document.encoder.encdec) *
       keyunchanged)   
   {
      window.setTimeout('upd()', 100);
      return;
   }

   ResizeTextArea(document.encoder.text);
   
   var e = document.getElementById('output');
   
   if (document.encoder.text.value == '')
   {
      e.innerHTML = 'Type in a message and see the results here!';
   }
   else
   {
	   var ckt = colkey_text;
	   if (document.encoder.use_as_column_order.checked) {
		   original = ckt.split(' ');
		   ckt = new Array(original.length);
		  
			for (var i = 0; i < original.length; i ++) {
				ckt[original[i] - 1] = i + 1;
			}

		   ckt = ckt.join(' ');
		}
      e.innerHTML = SwapSpaces(HTMLEscape(ColTrans(document.encoder.encdec.value * 1,
         document.encoder.text.value, ckt)));
   }
   
   window.setTimeout('upd()', 100);
}

function insert_example()
{
   document.encoder.encdec.value = "1";
   document.encoder.colkey.value = "4 2 5 3 1";
   document.encoder.colkey_type.value = "num";
   document.encoder.use_as_column_order.checked= false;
   document.encoder.text.value = "WHICHWRISTWATCHESARESWISSWRISTWATCHES";
}

function insert_example2()
{
   document.encoder.encdec.value = "-1";
   document.encoder.colkey.value = "4 2 5 3 1";
   document.encoder.colkey_type.value = "num";
   document.encoder.use_as_column_order.checked = false;
   document.encoder.text.value = "HTHESTHHRASWRASCSCRSSCWWWESWWEIITAIIT";
}

function start_update()
{
   if (! document.getElementById)
   {
      alert('Sorry, you need a newer browser.');
      return;
   }

   if ((! document.ColTrans_Loaded) || (! document.Util_Loaded) ||
       (! document.getElementById('output')) ||
       (! document.getElementById('colkey_out')))
   {
      window.setTimeout('start_update()', 100);
      return;
   }
   upd();
}


window.setTimeout('start_update()', 100);

// --></script>
<link rel="stylesheet" type="text/css" href="base.css">
<link rel="stylesheet" type="text/css" media="screen,projection" href="valentine.css">
<link rel="stylesheet" type="text/css" media="print" href="print.css">
<script src="/inc/js/site.js?1" type="text/javascript"></script>
<style type="text/css">
  #content img {
    position: absolute;
    top: 0px;
    left: 0px;
}
</style>
</head>
<body>
<div id="content">
    <img src="logo.jpg" width="400px" height="100px">
</div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<table width="100%" height="100%" cellspacing="0" cellpadding="0" border="0">
<tbody><tr><td valign="top">
<table width="100%" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td width="99%" valign="top"><div class="r_main">

<p>A columnar transposition, also known as a row-column transpose,
 is a very simple cipher to perform by hand.
First, you write your message in columns.  Then, you just rearrange the
columns.  For example.  I have the message, "Which wristwatches are swiss
wristwatches."  You convert everything to upper case and write it without
spaces.  When you write it down, make sure to put it into columns and number
them.  Let's use five columns.</p>

<table cellspacing="0" cellpadding="3" border="1" align="center">
<tbody><tr><td>&nbsp;</td><th>Unencoded</th><th>Rearranged</th></tr>
<tr><td valign="top">
<b>Column #:</b>
</td><td>
<tt><b><u>4 2 5 3 1</u></b><br>
W H I C H<br>
W R I S T<br>
W A T C H<br>
E S A R E<br>
S W I S S<br>
W R I S T<br>
W A T C H<br>
E S</tt>
</td><td>
<tt><b><u>1 2 3 4 5</u></b><br>
H H C W I<br>
T R S W I<br>
H A C W T<br>
E S R E A<br>
S W S S I<br>
T R S W I<br>
H A C W T<br>
&nbsp; S &nbsp; E</tt>
</td></tr>
</tbody></table>

<p>Now, you just read the columns down in the order that you number them.
Above, you will see the key is 4 2 5 3 1, which means you write down the
last column first, then the second, then the fourth, the first, and finally
the middle.  When you are all done, you will get
"HTHESTHHRASWRASCSCRSSCWWWESWWEIITAIIT".  I can put the example's information
into the encoder for you:  
<a href="#" onclick="insert_example(); return false">Encode</a> or
<a href="#" onclick="insert_example2(); return false">Decode</a></p>

<p>This columnar transposition cipher implementation will also move spaces
around, so you can take "a b c" with a key of "2 1" and get "&nbsp;&nbsp;abc" (note
the two spaces in front).  I suggest you remove all spaces before you encode
the text, but they should be preserved even if you don't.  Newlines are ignored and not taken into consideration.</p>

<form name="encoder" method="post" action="#" onsubmit="return false;">
<p><select name="encdec" _oldvalue="1"><option value="1">Encrypt
</option><option value="-1">Decrypt</option></select></p>
<p><select name="colkey_type" _oldvalue="num"><option value="num">Numeric Key - Spaced Numbers
</option><option value="alpha">Key Word(s) - Duplicates numbered forwards
</option><option value="ahpla">Key Word(s) - Duplicates numbered backwards
</option></select>:  <input type="text" name="colkey" _oldvalue=""><br>
The resulting columnar key:  <b><span id="colkey_out">1</span></b><br>
<input type="checkbox" name="use_as_column_order" _oldvalue="false"> - <label for="use_as_column_order">Use the key as column order instead of column labels</label></p>
<p><textarea name="text" rows="2" cols="40" _oldvalue=""></textarea></p>
</form>
<p>This is your encoded or decoded text:</p>
<table class="r_box" style="margin-top: 8px; margin-bottom: 8px;font-family: monospace" cellspacing="0" cellpadding="0" border="0" align="center"><tbody><tr><td class="r_box"><span id="output">Type in a message and see the results here!</span>
</td></tr></tbody></table><div style="clear: both"></div>
</div>
<img src="logo.jpg" style="float: right; margin-left: 2px; margin-bottom: 2px; height:100px">
</td></tr></tbody></table>
</td></tr>
</tbody></table>


</body></html>